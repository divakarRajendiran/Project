/*
Copyright (c) 1997, 1998 Carnegie Mellon University.  All Rights
Reserved. 

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.
3. The name of the author may not be used to endorse or promote products
derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

The AODV code developed by the CMU/MONARCH group was optimized and tuned by Samir Das and Mahesh Marina, University of Cincinnati. The work was partially done in Sun Microsystems. Modified for gratuitous replies by Anant Utgikar, 09/16/02.

*/

//#include <ip.h>

#include <aodv/aodv.h>
#include <aodv/aodv_packet.h>
#include <random.h>
#include <cmu-trace.h>
//#include <energy-model.h>

#define max(a,b)        ( (a) > (b) ? (a) : (b) )
#define CURRENT_TIME    Scheduler::instance().clock()

//#define DEBUG
//#define ERROR

#ifdef DEBUG
static int extra_route_reply = 0;
static int limit_route_request = 0;
static int route_request = 0;
#endif


/*
  TCL Hooks
*/


int hdr_aodv::offset_;
static class AODVHeaderClass : public PacketHeaderClass {
public:
        AODVHeaderClass() : PacketHeaderClass("PacketHeader/AODV",
                                              sizeof(hdr_all_aodv)) {
    bind_offset(&hdr_aodv::offset_);
	} 
} class_rtProtoAODV_hdr;

static class AODVclass : public TclClass {
public:
        AODVclass() : TclClass("Agent/AODV") {}
        TclObject* create(int argc, const char*const* argv) {
          assert(argc == 5);
          //return (new AODV((nsaddr_t) atoi(argv[4])));
	  return (new AODV((nsaddr_t) Address::instance().str2addr(argv[4])));
        }
} class_rtProtoAODV;


int
AODV::command(int argc, const char*const* argv) {
  if(argc == 2) {
  Tcl& tcl = Tcl::instance();
    
    if(strncasecmp(argv[1], "id", 2) == 0) {
      tcl.resultf("%d", index);
      return TCL_OK;
    }

if(strcmp(argv[1], "hacker") == 0){

malicious = true;
  return TCL_OK;
	
	}

    
    if(strncasecmp(argv[1], "start", 2) == 0) {
      btimer.handle((Event*) 0);

//#ifndef AODV_LINK_LAYER_DETECTION
      htimer.handle((Event*) 0);
      ntimer.handle((Event*) 0);
//#endif // LINK LAYER DETECTION

      rtimer.handle((Event*) 0);
      return TCL_OK;
     }               
  }
  else if(argc == 3) {
    if(strcmp(argv[1], "index") == 0) {
      index = atoi(argv[2]);
      return TCL_OK;
    }

    else if(strcmp(argv[1], "log-target") == 0 || strcmp(argv[1], "tracetarget") == 0) {
      logtarget = (Trace*) TclObject::lookup(argv[2]);
      if(logtarget == 0)
	return TCL_ERROR;
      return TCL_OK;
    }
    else if(strcmp(argv[1], "drop-target") == 0) {
    int stat = rqueue.command(argc,argv);
      if (stat != TCL_OK) return stat;
      return Agent::command(argc, argv);
    }
    else if(strcmp(argv[1], "if-queue") == 0) {
    ifqueue = (PriQueue*) TclObject::lookup(argv[2]);
      
      if(ifqueue == 0)
	return TCL_ERROR;
      return TCL_OK;
    }
    else if (strcmp(argv[1], "port-dmux") == 0) {
    	dmux_ = (PortClassifier *)TclObject::lookup(argv[2]);
	if (dmux_ == 0) {
		fprintf (stderr, "%s: %s lookup of %s failed\n", __FILE__,
		argv[1], argv[2]);
		return TCL_ERROR;
	}
	return TCL_OK;
    }
  }
  return Agent::command(argc, argv);
}

/* 
   Constructor
*/

AODV::AODV(nsaddr_t id) : Agent(PT_AODV),
			  btimer(this), htimer(this), ntimer(this), 
			  rtimer(this), lrtimer(this), rqueue() {
 
                
  index = id;
  seqno = 2;
  bid = 1;
i=0;
j=0;
ss=0;
ss1=0;
/*for(i=0;i<50;i++)
{
for(j=0;j<50;j++)
{
nn[i][j]=NULL;
}
}*/

for(i=0;i<50;i++)
{
val[i]=rreq[i]=NULL;
val1[i]=rrep[i]=NULL;
rrep1[i]=rreq1[i]=rreq2[i]=rrep2[i]=NULL;
ab[i]=ab1[i]=ab2[i]=NULL;
rs[i]=rf[i]=NULL;
tt[i]=tt1[i]=NULL;
rqs[i]=rqf[i]=NULL;
}
for (i=0;i<50;i++)
{
val[i]=i;
val1[i]=i;

//nn[i][0]=i;
}  

/*for(i=0;i<50;i++)
{
printf("\n%d",nn[i][0]);
}*/
rreqcall();
/*for(i=0;i<50;i++)
{
printf("\n%d\t%d",val[i],rreq1[i]);
}*/
//rreqcall();
//rreq1call();
rrepcall();
/*for(i=0;i<50;i++)
{
printf("\n%d\t%d",val[i],rrep1[i]);
}*/

abcall();
/*for(i=0;i<50;i++)
{
printf("\n%d\t%d",val[i],ab1[i]);
}*/


reqmember();
repmember();
abmember();
tcal();
tprint();

/*for(i=0;i<50;i++)
{
printf("%d",val[i]);
}*/
malicious = false;
	


  LIST_INIT(&nbhead);
  LIST_INIT(&bihead);

  logtarget = 0;
  ifqueue = 0;
}

/*
  Timers
*/

void
BroadcastTimer::handle(Event*) {
  agent->id_purge();
  Scheduler::instance().schedule(this, &intr, BCAST_ID_SAVE);
}

void
HelloTimer::handle(Event*) {
   agent->sendHello();
   double interval = MinHelloInterval + 
                 ((MaxHelloInterval - MinHelloInterval) * Random::uniform());
   assert(interval >= 0);
   Scheduler::instance().schedule(this, &intr, interval);
}

void
NeighborTimer::handle(Event*) {
  agent->nb_purge();
  Scheduler::instance().schedule(this, &intr, HELLO_INTERVAL);
}

void
RouteCacheTimer::handle(Event*) {
  agent->rt_purge();
#define FREQUENCY 0.5 // sec
  Scheduler::instance().schedule(this, &intr, FREQUENCY);
}

void
LocalRepairTimer::handle(Event* p)  {  // SRD: 5/4/99
aodv_rt_entry *rt;
struct hdr_ip *ih = HDR_IP( (Packet *)p);

   /* you get here after the timeout in a local repair attempt */
   /*	fprintf(stderr, "%s\n", __FUNCTION__); */


    rt = agent->rtable.rt_lookup(ih->daddr());
	
    if (rt && rt->rt_flags != RTF_UP) {
    // route is yet to be repaired
    // I will be conservative and bring down the route
    // and send route errors upstream.
    /* The following assert fails, not sure why */
    /* assert (rt->rt_flags == RTF_IN_REPAIR); */
		
      //rt->rt_seqno++;
      agent->rt_down(rt);
      // send RERR
#ifdef DEBUG
      fprintf(stderr,"Node %d: Dst - %d, failed local repair\n",index, rt->rt_dst);
#endif      
    }
    Packet::free((Packet *)p);
}


/*
   Broadcast ID Management  Functions
*/


void
AODV::id_insert(nsaddr_t id, u_int32_t bid) {
BroadcastID *b = new BroadcastID(id, bid);

 assert(b);
 b->expire = CURRENT_TIME + BCAST_ID_SAVE;
 LIST_INSERT_HEAD(&bihead, b, link);
}

/* SRD */
bool
AODV::id_lookup(nsaddr_t id, u_int32_t bid) {
BroadcastID *b = bihead.lh_first;
 
 // Search the list for a match of source and bid
 for( ; b; b = b->link.le_next) {
   if ((b->src == id) && (b->id == bid))
     return true;     
 }
 return false;
}

void
AODV::id_purge() {
BroadcastID *b = bihead.lh_first;
BroadcastID *bn;
double now = CURRENT_TIME;

 for(; b; b = bn) {
   bn = b->link.le_next;
   if(b->expire <= now) {
     LIST_REMOVE(b,link);
     delete b;
   }
 }
}

/*
  Helper Functions
*/

double
AODV::PerHopTime(aodv_rt_entry *rt) {
int num_non_zero = 0, i;
double total_latency = 0.0;

 if (!rt)
   return ((double) NODE_TRAVERSAL_TIME );
	
 for (i=0; i < MAX_HISTORY; i++) {
   if (rt->rt_disc_latency[i] > 0.0) {
      num_non_zero++;
      total_latency += rt->rt_disc_latency[i];
   }
 }
 if (num_non_zero > 0)
   return(total_latency / (double) num_non_zero);
 else
   return((double) NODE_TRAVERSAL_TIME);

}

/*
  Link Failure Management Functions
*/

static void
aodv_rt_failed_callback(Packet *p, void *arg) {
  ((AODV*) arg)->rt_ll_failed(p);
}

/*
 * This routine is invoked when the link-layer reports a route failed.
 */
void
AODV::rt_ll_failed(Packet *p) {
struct hdr_cmn *ch = HDR_CMN(p);
struct hdr_ip *ih = HDR_IP(p);
aodv_rt_entry *rt;
nsaddr_t broken_nbr = ch->next_hop_;

#ifndef AODV_LINK_LAYER_DETECTION
 drop(p, DROP_RTR_MAC_CALLBACK);
#else 

 /*
  * Non-data packets and Broadcast Packets can be dropped.
  */
  if(! DATA_PACKET(ch->ptype()) ||
     (u_int32_t) ih->daddr() == IP_BROADCAST) {
    drop(p, DROP_RTR_MAC_CALLBACK);
    return;
  }
  log_link_broke(p);
	if((rt = rtable.rt_lookup(ih->daddr())) == 0) {
    drop(p, DROP_RTR_MAC_CALLBACK);
    return;
  }
  log_link_del(ch->next_hop_);

#ifdef AODV_LOCAL_REPAIR
  /* if the broken link is closer to the dest than source, 
     attempt a local repair. Otherwise, bring down the route. */


  if (ch->num_forwards() > rt->rt_hops) {
    local_rt_repair(rt, p); // local repair
    // retrieve all the packets in the ifq using this link,
    // queue the packets for which local repair is done, 
    return;
  }
  else	
#endif // LOCAL REPAIR	

  {
    drop(p, DROP_RTR_MAC_CALLBACK);
    // Do the same thing for other packets in the interface queue using the
    // broken link -Mahesh
while((p = ifqueue->filter(broken_nbr))) {
     drop(p, DROP_RTR_MAC_CALLBACK);
    }	
    nb_delete(broken_nbr);
  }

#endif // LINK LAYER DETECTION
}

void
AODV::handle_link_failure(nsaddr_t id) {
aodv_rt_entry *rt, *rtn;
Packet *rerr = Packet::alloc();
struct hdr_aodv_error *re = HDR_AODV_ERROR(rerr);

 re->DestCount = 0;
 for(rt = rtable.head(); rt; rt = rtn) {  // for each rt entry
   rtn = rt->rt_link.le_next; 
   if ((rt->rt_hops != INFINITY2) && (rt->rt_nexthop == id) ) {
     assert (rt->rt_flags == RTF_UP);
     assert((rt->rt_seqno%2) == 0);
     rt->rt_seqno++;
     re->unreachable_dst[re->DestCount] = rt->rt_dst;
     re->unreachable_dst_seqno[re->DestCount] = rt->rt_seqno;
#ifdef DEBUG
     fprintf(stderr, "%s(%f): %d\t(%d\t%u\t%d)\n", __FUNCTION__, CURRENT_TIME,
		     index, re->unreachable_dst[re->DestCount],
		     re->unreachable_dst_seqno[re->DestCount], rt->rt_nexthop);
#endif // DEBUG
     re->DestCount += 1;
     rt_down(rt);
   }
   // remove the lost neighbor from all the precursor lists
   rt->pc_delete(id);
 }   

 if (re->DestCount > 0) {
#ifdef DEBUG
   fprintf(stderr, "%s(%f): %d\tsending RERR...\n", __FUNCTION__, CURRENT_TIME, index);
#endif // DEBUG
   sendError(rerr, false);
 }
 else {
   Packet::free(rerr);
 }
}

void
AODV::local_rt_repair(aodv_rt_entry *rt, Packet *p) {
#ifdef DEBUG
  fprintf(stderr,"%s: Dst - %d\n", __FUNCTION__, rt->rt_dst); 
#endif  
  // Buffer the packet 
  rqueue.enque(p);

  // mark the route as under repair 
  rt->rt_flags = RTF_IN_REPAIR;
 
sendRequest(rt->rt_dst);
//printf("%d",index);
rreq_lookup(index);

  // set up a timer interrupt
  Scheduler::instance().schedule(&lrtimer, p->copy(), rt->rt_req_timeout);
}

void
AODV::rt_update(aodv_rt_entry *rt, u_int32_t seqnum, u_int16_t metric,
	       	nsaddr_t nexthop, double expire_time) {

     rt->rt_seqno = seqnum;
     rt->rt_hops = metric;
     rt->rt_flags = RTF_UP;
     rt->rt_nexthop = nexthop;
     rt->rt_expire = expire_time;
}

void
AODV::rt_down(aodv_rt_entry *rt) {
  /*
   *  Make sure that you don't "down" a route more than once.
   */

  if(rt->rt_flags == RTF_DOWN) {
    return;
  }

  // assert (rt->rt_seqno%2); // is the seqno odd?
  rt->rt_last_hop_count = rt->rt_hops;
  rt->rt_hops = INFINITY2;
  rt->rt_flags = RTF_DOWN;
  rt->rt_nexthop = 0;
  rt->rt_expire = 0;

} /* rt_down function */



void  
AODV::rt_print(nsaddr_t node_id)
{
FILE *out_file ;
char nowfile[50] = "rtable.txt";

out_file = fopen(nowfile, "a");

aodv_rt_entry *rt;

fprintf(out_file,"=======================================================\n");
   
for(rt=rtable.head(); rt; rt = rt->rt_link.le_next) {
fprintf(out_file, "NODE: %i\t  %.4lf\t  %i\t  %i\t  %i\t  %i\t  %.4lf\t  %d\n", node_id, CURRENT_TIME, rt->rt_dst, rt->rt_nexthop, rt->rt_hops, rt->rt_seqno, rt->rt_expire, rt->rt_flags);
}
	 
  fclose(out_file);
}

void
AODV::rprint()
{

FILE *out_file ;
char nowfile[150] = "rreq1.txt";

out_file = fopen(nowfile, "a");

for (i=0;i<50;i++)
{
fprintf(out_file, "%d \t %d\n",val[i],rreq[i]);
}
fclose(out_file);

}
void
AODV::rprint1()
{

FILE *out_file ;
char nowfile[50] = "rrep1.txt";

out_file = fopen(nowfile, "a");
for (i=0;i<50;i++)
{
fprintf(out_file, "%d \t %d\n",val[i],rrep[i]);
}
fclose(out_file);

///for (i=0;i<5;i++)
//{
//printf("\nstart");
/*printf("\n%d\t\t%d",val1[0],rrep[0]);
printf("\n%d\t\t%d",val1[1],rrep[1]);
printf("\n%d\t\t%d",val1[2],rrep[2]);
printf("\n%d\t\t%d",val1[3],rrep[3]);
printf("\n%d\t\t%d",val1[4],rrep[4]);
printf("\n%d\t\t%d",val1[5],rrep[5]);
printf("\n%d\t\t%d",val1[6],rrep[6]);
printf("\n%d\t\t%d",val1[7],rrep[7]);
printf("\n%d\t\t%d",val1[8],rrep[8]);
printf("\n%d\t\t%d",val1[9],rrep[9]);
*/
//printf("\nend");
//printf("\n%d\t\t%d",val[i],rreq[i]);
//}

}

void
AODV::rprint2()
{

FILE *out_file ;
char nowfile[50] = "ab1.txt";

out_file = fopen(nowfile, "a");
for (i=0;i<50;i++)
{
fprintf(out_file, "%d \t %d\n",val[i],ab[i]);
}
fclose(out_file);

}
/*
  Route Handling Functions
*/

void
AODV::rt_resolve(Packet *p) {
struct hdr_cmn *ch = HDR_CMN(p);
struct hdr_ip *ih = HDR_IP(p);
aodv_rt_entry *rt;

 /*
  *  Set the transmit failure callback.  That
  *  won't change.
  */
 ch->xmit_failure_ = aodv_rt_failed_callback;
 ch->xmit_failure_data_ = (void*) this;
	rt = rtable.rt_lookup(ih->daddr());
 if(rt == 0) {
	  rt = rtable.rt_add(ih->daddr());
 }

 /*
  * If the route is up, forward the packet 
  */
	//rprint();
 if(rt->rt_flags == RTF_UP) {
   assert(rt->rt_hops != INFINITY2);
//printf("\nrt resolve%d\t\t%d",index,rt->rt_dst);   
forward(rt, p, NO_DELAY);
 }
 /*
  *  if I am the source of the packet, then do a Route Request.
  */
	else if(ih->saddr() == index) {
   rqueue.enque(p);
   sendRequest(rt->rt_dst);
//printf("%d",index);	
//rreq_lookup(index);
 }
 /*
  *	A local repair is in progress. Buffer the packet. 
  */
 else if (rt->rt_flags == RTF_IN_REPAIR) {
   rqueue.enque(p);
 }

 /*
  * I am trying to forward a packet for someone else to which
  * I don't have a route.
  */
 else {
 Packet *rerr = Packet::alloc();
 struct hdr_aodv_error *re = HDR_AODV_ERROR(rerr);
 /* 
  * For now, drop the packet and send error upstream.
  * Now the route errors are broadcast to upstream
  * neighbors - Mahesh 09/11/99
  */	
 
   assert (rt->rt_flags == RTF_DOWN);
   re->DestCount = 0;
   re->unreachable_dst[re->DestCount] = rt->rt_dst;
   re->unreachable_dst_seqno[re->DestCount] = rt->rt_seqno;
   re->DestCount += 1;
#ifdef DEBUG
   fprintf(stderr, "%s: sending RERR...\n", __FUNCTION__);
#endif
   sendError(rerr, false);

   drop(p, DROP_RTR_NO_ROUTE);
 }

}

void
AODV::rt_purge() {
aodv_rt_entry *rt, *rtn;
double now = CURRENT_TIME;
double delay = 0.0;
Packet *p;

 for(rt = rtable.head(); rt; rt = rtn) {  // for each rt entry
   rtn = rt->rt_link.le_next;
   if ((rt->rt_flags == RTF_UP) && (rt->rt_expire < now)) {
   // if a valid route has expired, purge all packets from 
   // send buffer and invalidate the route.                    
	assert(rt->rt_hops != INFINITY2);
     while((p = rqueue.deque(rt->rt_dst))) {
#ifdef DEBUG
       fprintf(stderr, "%s: calling drop()\n",
                       __FUNCTION__);
#endif // DEBUG
       drop(p, DROP_RTR_NO_ROUTE);
     }
     rt->rt_seqno++;
     assert (rt->rt_seqno%2);
     rt_down(rt);
   }
   else if (rt->rt_flags == RTF_UP) {
   // If the route is not expired,
   // and there are packets in the sendbuffer waiting,
   // forward them. This should not be needed, but this extra 
   // check does no harm.
     assert(rt->rt_hops != INFINITY2);
     while((p = rqueue.deque(rt->rt_dst))) {
       forward (rt, p, delay);
       delay += ARP_DELAY;
     }
   } 
   else if (rqueue.find(rt->rt_dst))
   // If the route is down and 
   // if there is a packet for this destination waiting in
   // the sendbuffer, then send out route request. sendRequest
   // will check whether it is time to really send out request
   // or not.
   // This may not be crucial to do it here, as each generated 
   // packet will do a sendRequest anyway.
   sendRequest(rt->rt_dst); 
	//rreq_lookup(index);
}
}

/*
  Packet Reception Routines
*/

void
AODV::recv(Packet *p, Handler*) {
struct hdr_cmn *ch = HDR_CMN(p);
struct hdr_ip *ih = HDR_IP(p);

 assert(initialized());
 //assert(p->incoming == 0);
 // XXXXX NOTE: use of incoming flag has been depracated; In order to track direction of pkt flow, direction_ in hdr_cmn is used instead. see packet.h for details.

 if(ch->ptype() == PT_AODV) {
   ih->ttl_ -= 1;
   recvAODV(p);
   return;
 }


 /*
  *  Must be a packet I'm originating...
  */
if((ih->saddr() == index) && (ch->num_forwards() == 0)) {
 /*
  * Add the IP Header
  */
   ch->size() += IP_HDR_LEN;
   // Added by Parag Dadhania && John Novatnack to handle broadcasting
   if ( (u_int32_t)ih->daddr() != IP_BROADCAST)
     ih->ttl_ = NETWORK_DIAMETER;
}
 /*
  *  I received a packet that I sent.  Probably
  *  a routing loop.
  */
else if(ih->saddr() == index) {
   drop(p, DROP_RTR_ROUTE_LOOP);
   return;
 }
 /*
  *  Packet I'm forwarding...
  */
 else {
 /*
  *  Check the TTL.  If it is zero, then discard.
  */
   if(--ih->ttl_ == 0) {
     drop(p, DROP_RTR_TTL);
     return;
   }
 }
// Added by Parag Dadhania && John Novatnack to handle broadcasting
 if ( (u_int32_t)ih->daddr() != IP_BROADCAST)
   rt_resolve(p);
 else
   forward((aodv_rt_entry*) 0, p, NO_DELAY);
}


void
AODV::recvAODV(Packet *p) {
 struct hdr_aodv *ah = HDR_AODV(p);

 assert(HDR_IP (p)->sport() == RT_PORT);
 assert(HDR_IP (p)->dport() == RT_PORT);

 /*
  * Incoming Packets.
  */
 switch(ah->ah_type) {

 case AODVTYPE_RREQ:
   recvRequest(p);
break;

 case AODVTYPE_RREP:
   recvReply(p);
//rprint();   
break;

 case AODVTYPE_RERR:
   recvError(p);
   break;

 case AODVTYPE_HELLO:
   recvHello(p);
   break;
        
 default:
   fprintf(stderr, "Invalid AODV type (%x)\n", ah->ah_type);
   exit(1);
 }

}


void
AODV::recvRequest(Packet *p) {
struct hdr_ip *ih = HDR_IP(p);
struct hdr_aodv_request *rq = HDR_AODV_REQUEST(p);
aodv_rt_entry *rt;

  /*
   * Drop if:
   *      - I'm the source
   *      - I recently heard this request.
   */

//rsmember(index);  
if(rq->rq_src == index) {
#ifdef DEBUG
    fprintf(stderr, "%s: got my own REQUEST\n", __FUNCTION__);
#endif // DEBUG
    Packet::free(p);
    return;
  } 

 if (id_lookup(rq->rq_src, rq->rq_bcast_id)) {

#ifdef DEBUG
   fprintf(stderr, "%s: discarding request\n", __FUNCTION__);
#endif // DEBUG
 
   Packet::free(p);
   return;
 }

 /*
  * Cache the broadcast ID
  */
 id_insert(rq->rq_src, rq->rq_bcast_id);



 /* 
  * We are either going to forward the REQUEST or generate a
  * REPLY. Before we do anything, we make sure that the REVERSE
  * route is in the route table.
  */
 aodv_rt_entry *rt0; // rt0 is the reverse route 
   
   rt0 = rtable.rt_lookup(rq->rq_src);
   if(rt0 == 0) { /* if not in the route table */
   // create an entry for the reverse route.
     rt0 = rtable.rt_add(rq->rq_src);
//printf("source %d",rq->rq_src);  

}
  
   rt0->rt_expire = max(rt0->rt_expire, (CURRENT_TIME + REV_ROUTE_LIFE));
//ss=rq->rq_src_seqno;
//mal_lookup(index,rq->rq_src_seqno);
   if ( (rq->rq_src_seqno > rt0->rt_seqno ) ||
    	((rq->rq_src_seqno == rt0->rt_seqno) && 
	 (rq->rq_hop_count < rt0->rt_hops)) ) {

 // If we have a fresher seq no. or lesser #hops for the 
   // same seq no., update the rt entry. Else don't bother.
rt_update(rt0, rq->rq_src_seqno, rq->rq_hop_count, ih->saddr(),
     	       max(rt0->rt_expire, (CURRENT_TIME + REV_ROUTE_LIFE)) );
     if (rt0->rt_req_timeout > 0.0) {
     // Reset the soft state and 
     // Set expiry time to CURRENT_TIME + ACTIVE_ROUTE_TIMEOUT
     // This is because route is used in the forward direction,
     // but only sources get benefited by this change
       rt0->rt_req_cnt = 0;
       rt0->rt_req_timeout = 0.0; 
       rt0->rt_req_last_ttl = rq->rq_hop_count;
       rt0->rt_expire = CURRENT_TIME + ACTIVE_ROUTE_TIMEOUT;
     }

     /* Find out whether any buffered packet can benefit from the 
      * reverse route.
      * May need some change in the following code - Mahesh 09/11/99
      */
     assert (rt0->rt_flags == RTF_UP);
     Packet *buffered_pkt;
     while ((buffered_pkt = rqueue.deque(rt0->rt_dst))) {
       if (rt0 && (rt0->rt_flags == RTF_UP)) {
	assert(rt0->rt_hops != INFINITY2);
         forward(rt0, buffered_pkt, NO_DELAY);
//printf("%d",rt0->rt_dst);       
}
     }
   } 
   // End for putting reverse route in rt table


 /*
  * We have taken care of the reverse route stuff.
  * Now see whether we can send a route reply. 
  */

 rt = rtable.rt_lookup(rq->rq_dst);

 // First check if I am the destination ..

 if(rq->rq_dst == index) {

#ifdef DEBUG
   fprintf(stderr, "%d - %s: destination sending reply\n",
                   index, __FUNCTION__);
#endif // DEBUG
rt_print(index);
               
   // Just to be safe, I use the max. Somebody may have
   // incremented the dst seqno.
   seqno = max(seqno, rq->rq_dst_seqno)+1;
   if (seqno%2) seqno++;
   sendReply(rq->rq_src,           // IP Destination
             1,                    // Hop Count
             index,                // Dest IP Address
             seqno,                // Dest Sequence Num
             MY_ROUTE_TIMEOUT,     // Lifetime
             rq->rq_timestamp);    // timestamp
 rrep_lookup(index);
//mal_lookup(index,seqno);
   Packet::free(p);
//rprint();
} 

 // I am not the destination, but I may have a fresh enough route.

 else if (rt && (rt->rt_hops != INFINITY2) && 
	  	(rt->rt_seqno >= rq->rq_dst_seqno) ) {

   //assert (rt->rt_flags == RTF_UP);
   assert(rq->rq_dst == rt->rt_dst);
   //assert ((rt->rt_seqno%2) == 0);	// is the seqno even?
if((t[rt0->rt_nexthop]=='S' || t[rt0->rt_nexthop]== 'H' || t[rt0->rt_nexthop]=='M')&& (t[index]=='S' || t[index]=='H' || t[index]=='M'))
{
   sendReply(rq->rq_src,
             rt->rt_hops + 1,
             rq->rq_dst,
             rt->rt_seqno,
	     (u_int32_t) (rt->rt_expire - CURRENT_TIME),
	     //             rt->rt_expire - CURRENT_TIME,
             rq->rq_timestamp);

rrep_lookup(index);
//mal_lookup(index,rt->rt_seqno);
//rreq_lookup(index);
   // Insert nexthops to RREQ source and RREQ destination in the
   // precursor lists of destination and source respectively
   rt->pc_insert(rt0->rt_nexthop); // nexthop to RREQ source
   rt0->pc_insert(rt->rt_nexthop); // nexthop to RREQ destination
}
#ifdef RREQ_GRAT_RREP  
if(t[rt0->rt_nexthop]=='S' || t[rt0->rt_nexthop]=='H' || t[rt->rt_nexthop]=='M')
{
sendReply(rq->rq_dst,
             rq->rq_hop_count,
             rq->rq_src,
             rq->rq_src_seqno,
	     (u_int32_t) (rt->rt_expire - CURRENT_TIME),
	     //             rt->rt_expire - CURRENT_TIME,
             rq->rq_timestamp);

rrep_lookup(index);
//mal_lookup(index,rq->rq_src_seqno);
}
#endif
   
// TODO: send grat RREP to dst if G flag set in RREQ using rq->rq_src_seqno, rq->rq_hop_counT
   
// DONE: Included gratuitous replies to be sent as per IETF aodv draft specification. As of now, G flag has not been dynamically used and is always set or reset in aodv-packet.h --- Anant Utgikar, 09/16/02.

	Packet::free(p);
 }
 /*
  * Can't reply. So forward the  Route Request
  */
else if (malicious==true)
   {
    ih->saddr() = index;
    ih->daddr() = IP_BROADCAST;
    rq->rq_src_seqno +=1;    
    rq->rq_hop_count -=1 ;
    rq->rq_dst_seqno -=1;
 //if (rt) rq->rq_dst_seqno = max(rt->rt_seqno, rq->rq_dst_seqno);
forward((aodv_rt_entry*) 0, p, DELAY);
ab[index]+=1;
mal_lookup(index,rq->rq_src_seqno);
rreq_lookup(index);
}
 else {
   ih->saddr() = index;
   ih->daddr() = IP_BROADCAST;
   rq->rq_hop_count += 1;
   // Maximum sequence number seen en route
   //if (rt) rq->rq_dst_seqno = max(rt->rt_seqno, rq->rq_dst_seqno);

forward((aodv_rt_entry*) 0, p, DELAY);
//rfmember(index);
rreq_lookup(index); 
mal_lookup(index,rq->rq_src_seqno);
//printf("%d",rt->rt_nexthop);

}
//cal();
//rprint();

}


void
AODV::recvReply(Packet *p) {
//struct hdr_cmn *ch = HDR_CMN(p);
struct hdr_ip *ih = HDR_IP(p);
struct hdr_aodv_reply *rp = HDR_AODV_REPLY(p);
aodv_rt_entry *rt;
char suppress_reply = 0;
double delay = 0.0;
AODV_Neighbor *nb;
	
#ifdef DEBUG
 fprintf(stderr, "%d - %s: received a REPLY\n", index, __FUNCTION__);
#endif // DEBUG
//rprint();
 /*
  *  Got a reply. So reset the "soft state" maintained for 
  *  route requests in the request table. We don't really have
  *  have a separate request table. It is just a part of the
  *  routing table itself. 
  */
 // Note that rp_dst is the dest of the data packets, not the
 // the dest of the reply, which is the src of the data packets.

//rqsmember(index);


 rt = rtable.rt_lookup(rp->rp_dst);
        
 /*
  *  If I don't have a rt entry to this host... adding
  */
 if(rt == 0) {
   rt = rtable.rt_add(rp->rp_dst);
 }

 /*
  * Add a forward route table entry... here I am following 
  * Perkins-Royer AODV paper almost literally - SRD 5/99
  */

 if ( (rt->rt_seqno < rp->rp_dst_seqno) ||   // newer route 
      ((rt->rt_seqno == rp->rp_dst_seqno) &&  
       (rt->rt_hops > rp->rp_hop_count)) ) { // shorter or better route
	
  // Update the rt entry 
  rt_update(rt, rp->rp_dst_seqno, rp->rp_hop_count,
		rp->rp_src, CURRENT_TIME + rp->rp_lifetime);

  // reset the soft state
  rt->rt_req_cnt = 0;
  rt->rt_req_timeout = 0.0; 
  rt->rt_req_last_ttl = rp->rp_hop_count;
  
if (ih->daddr() == index) { // If I am the original source
  // Update the route discovery latency statistics
  // rp->rp_timestamp is the time of request origination
   rt_print(index);		
    rt->rt_disc_latency[(unsigned char)rt->hist_indx] = (CURRENT_TIME - rp->rp_timestamp)
                                         / (double) rp->rp_hop_count;
    // increment indx for next time
    rt->hist_indx = (rt->hist_indx + 1) % MAX_HISTORY;
  }	

  /*
   * Send all packets queued in the sendbuffer destined for
   * this destination. 
   * XXX - observe the "second" use of p.
   */
  Packet *buf_pkt;
  while((buf_pkt = rqueue.deque(rt->rt_dst))) {
    if(rt->rt_hops != INFINITY2) {
          assert (rt->rt_flags == RTF_UP);
    // Delay them a little to help ARP. Otherwise ARP 
    // may drop packets. -SRD 5/23/99      
forward(rt, buf_pkt, delay);
      delay += ARP_DELAY;
    }
  }
 }
 else {
  suppress_reply = 1;
 }

 /*
  * If reply is for me, discard it.
  */

if(ih->daddr() == index || suppress_reply) {
   Packet::free(p);
 }
 /*
  * Otherwise, forward the Route Reply.
  */
else if(malicious==true)
{
aodv_rt_entry *rt0 = rtable.rt_lookup(ih->daddr());
if(rt0 && (rt0->rt_hops != INFINITY2)) {
        assert (rt0->rt_flags == RTF_UP);
rp->rp_hop_count -=1;
rp->rp_dst_seqno +=1;
if(t[rt0->rt_nexthop]=='S'||t[rt0->rt_nexthop]=='H' || t[rt0->rt_nexthop]=='M')
{
forward(rt0, p, NO_DELAY);
//rqfmember(index);
//printf("forwarding%i",index);
rrep_lookup(index);
//mal_lookup1(index,rp->rp_dst_seqno);

//printf("NEXTHOP MAL:%i",rt0->rt_nexthop);
rt->pc_insert(rt0->rt_nexthop); // nexthop to RREQ source
}} }

 else {
 // Find the rt entry
aodv_rt_entry *rt0 = rtable.rt_lookup(ih->daddr());
   // If the rt is up, forward
   if(rt0 && (rt0->rt_hops != INFINITY2)) {
        assert (rt0->rt_flags == RTF_UP);
     rp->rp_hop_count += 1;
     rp->rp_src = index; 
//rqfmember(index);
if ((t[rt0->rt_nexthop]=='S'|| t[rt0->rt_nexthop]=='H' || t[rt0->rt_nexthop]=='M')&&(t[index]=='S'||t[index]=='H' ||t[index]=='M' ))
{
forward(rt0, p, NO_DELAY);

//printf("forwarding %i",index);
//mal_lookup1(index,rp->rp_dst_seqno);
rrep_lookup(index);  
// Insert the nexthop towards the RREQ source to 
     // the precursor list of the RREQ destination
     rt->pc_insert(rt0->rt_nexthop); // nexthop to RREQ source
//printf("NextHOP:%i",rt0->rt_nexthop);     
}
  else
	{
     drop(p, DROP_RTR_NO_ROUTE);
	}}
   else {
   // I don't know how to forward .. drop the reply. 
#ifdef DEBUG
     fprintf(stderr, "%s: dropping Route Reply\n", __FUNCTION__);
#endif // DEBUG
     drop(p, DROP_RTR_NO_ROUTE);
   }
 }
//cal1();
//rprint();
//y("\n%d",i);
//printf("\t\n%d",j);
//rprint1();
//rprint2();
}


void
AODV::recvError(Packet *p) {
struct hdr_ip *ih = HDR_IP(p);
struct hdr_aodv_error *re = HDR_AODV_ERROR(p);
aodv_rt_entry *rt;
u_int8_t i;
Packet *rerr = Packet::alloc();
struct hdr_aodv_error *nre = HDR_AODV_ERROR(rerr);

 
nre->DestCount = 0;
//cal1();
//rprint();
//rprint1(); 
for (i=0; i<re->DestCount; i++) {
 // For each unreachable destination
   rt = rtable.rt_lookup(re->unreachable_dst[i]);
   if ( rt && (rt->rt_hops != INFINITY2) &&
	(rt->rt_nexthop == ih->saddr()) &&
     	(rt->rt_seqno <= re->unreachable_dst_seqno[i]) ) {
	assert(rt->rt_flags == RTF_UP);
	assert((rt->rt_seqno%2) == 0); // is the seqno even?
//mal_lookup(index,rt->rt_seqno);
#ifdef DEBUG
     fprintf(stderr, "%s(%f): %d\t(%d\t%u\t%d)\t(%d\t%u\t%d)\n", __FUNCTION__,CURRENT_TIME,
		     index, rt->rt_dst, rt->rt_seqno, rt->rt_nexthop,
		     re->unreachable_dst[i],re->unreachable_dst_seqno[i],
	             ih->saddr());
#endif // DEBUG
     	rt->rt_seqno = re->unreachable_dst_seqno[i];
     	rt_down(rt);

   // Not sure whether this is the right thing to do
   Packet *pkt;
	while((pkt = ifqueue->filter(ih->saddr()))) {
        	drop(pkt, DROP_RTR_MAC_CALLBACK);
     	}

     // if precursor list non-empty add to RERR and delete the precursor list
     	if (!rt->pc_empty()) {
     		nre->unreachable_dst[nre->DestCount] = rt->rt_dst;
     		nre->unreachable_dst_seqno[nre->DestCount] = rt->rt_seqno;
     		nre->DestCount += 1;
		rt->pc_delete();
     	}
   }
 } 

 if (nre->DestCount > 0) {
#ifdef DEBUG
   fprintf(stderr, "%s(%f): %d\t sending RERR...\n", __FUNCTION__, CURRENT_TIME, index);
#endif // DEBUG
   sendError(rerr);
 }
 else {
   Packet::free(rerr);
 }

 Packet::free(p);
//rprint1();
}


/*
   Packet Transmission Routines
*/

void
AODV::forward(aodv_rt_entry *rt, Packet *p, double delay) {
struct hdr_cmn *ch = HDR_CMN(p);
struct hdr_ip *ih = HDR_IP(p);

 if(ih->ttl_ == 0) {

#ifdef DEBUG
  fprintf(stderr, "%s: calling drop()\n", __PRETTY_FUNCTION__);
#endif // DEBUG
 
  drop(p, DROP_RTR_TTL);
  return;
 }

 if (ch->ptype() != PT_AODV && ch->direction() == hdr_cmn::UP &&
	((u_int32_t)ih->daddr() == IP_BROADCAST)
		|| (ih->daddr() == here_.addr_)) {
	dmux_->recv(p,0);
	return;
 }

 if (rt) {
   assert(rt->rt_flags == RTF_UP);
   rt->rt_expire = CURRENT_TIME + ACTIVE_ROUTE_TIMEOUT;
   ch->next_hop_ = rt->rt_nexthop;
   ch->addr_type() = NS_AF_INET;
   ch->direction() = hdr_cmn::DOWN;       //important: change the packet's direction
 }
 else { // if it is a broadcast packet
   // assert(ch->ptype() == PT_AODV); // maybe a diff pkt type like gaf
   assert(ih->daddr() == (nsaddr_t) IP_BROADCAST);
   ch->addr_type() = NS_AF_NONE;
   ch->direction() = hdr_cmn::DOWN;       //important: change the packet's direction
 }

if (ih->daddr() == (nsaddr_t) IP_BROADCAST) {
 // If it is a broadcast packet
   assert(rt == 0);
   /*
    *  Jitter the sending of broadcast packets by 10ms
    */
   Scheduler::instance().schedule(target_, p,
      				   0.01 * Random::uniform());
 }
 else { // Not a broadcast packet 
   if(delay > 0.0) {
     Scheduler::instance().schedule(target_, p, delay);
   }
   else {
   // Not a broadcast packet, no delay, send immediately
     Scheduler::instance().schedule(target_, p, 0.);
   }
 }

}


void
AODV::sendRequest(nsaddr_t dst) {
// Allocate a RREQ packet 
Packet *p = Packet::alloc();
struct hdr_cmn *ch = HDR_CMN(p);
struct hdr_ip *ih = HDR_IP(p);
struct hdr_aodv_request *rq = HDR_AODV_REQUEST(p);
aodv_rt_entry *rt = rtable.rt_lookup(dst);

 assert(rt);

 /*
  *  Rate limit sending of Route Requests. We are very conservative
  *  about sending out route requests. 
  */

 if (rt->rt_flags == RTF_UP) {
   assert(rt->rt_hops != INFINITY2);
   Packet::free((Packet *)p);
   return;
 }

 if (rt->rt_req_timeout > CURRENT_TIME) {
   Packet::free((Packet *)p);
   return;
 }

 // rt_req_cnt is the no. of times we did network-wide broadcast
 // RREQ_RETRIES is the maximum number we will allow before 
 // going to a long timeout.

 if (rt->rt_req_cnt > RREQ_RETRIES) {
   rt->rt_req_timeout = CURRENT_TIME + MAX_RREQ_TIMEOUT;
   rt->rt_req_cnt = 0;
 Packet *buf_pkt;
   while ((buf_pkt = rqueue.deque(rt->rt_dst))) {
       drop(buf_pkt, DROP_RTR_NO_ROUTE);
   }
   Packet::free((Packet *)p);
   return;
 }

#ifdef DEBUG
   fprintf(stderr, "(%2d) - %2d sending Route Request, dst: %d\n",
                    ++route_request, index, rt->rt_dst);
#endif // DEBUG

 // Determine the TTL to be used this time. 
 // Dynamic TTL evaluation - SRD

 rt->rt_req_last_ttl = max(rt->rt_req_last_ttl,rt->rt_last_hop_count);

 if (0 == rt->rt_req_last_ttl) {
 // first time query broadcast
   ih->ttl_ = TTL_START;
 }
 else {
 // Expanding ring search.
   if (rt->rt_req_last_ttl < TTL_THRESHOLD)
     ih->ttl_ = rt->rt_req_last_ttl + TTL_INCREMENT;
   else {
   // network-wide broadcast
     ih->ttl_ = NETWORK_DIAMETER;
     rt->rt_req_cnt += 1;
   }
 }

 // remember the TTL used  for the next time
 rt->rt_req_last_ttl = ih->ttl_;

 // PerHopTime is the roundtrip time per hop for route requests.
 // The factor 2.0 is just to be safe .. SRD 5/22/99
 // Also note that we are making timeouts to be larger if we have 
 // done network wide broadcast before. 

 rt->rt_req_timeout = 2.0 * (double) ih->ttl_ * PerHopTime(rt); 
 if (rt->rt_req_cnt > 0)
   rt->rt_req_timeout *= rt->rt_req_cnt;
 rt->rt_req_timeout += CURRENT_TIME;

 // Don't let the timeout to be too large, however .. SRD 6/8/99
 if (rt->rt_req_timeout > CURRENT_TIME + MAX_RREQ_TIMEOUT)
   rt->rt_req_timeout = CURRENT_TIME + MAX_RREQ_TIMEOUT;
 rt->rt_expire = 0;

#ifdef DEBUG
 fprintf(stderr, "(%2d) - %2d sending Route Request, dst: %d, tout %f ms\n",
	         ++route_request, 
		 index, rt->rt_dst, 
		 rt->rt_req_timeout - CURRENT_TIME);
#endif	// DEBUG
	

 // Fill out the RREQ packet 
 // ch->uid() = 0;
 ch->ptype() = PT_AODV;
 ch->size() = IP_HDR_LEN + rq->size();
 ch->iface() = -2;
 ch->error() = 0;
 ch->addr_type() = NS_AF_NONE;
 ch->prev_hop_ = index;          // AODV hack

 ih->saddr() = index;
 ih->daddr() = IP_BROADCAST;
 ih->sport() = RT_PORT;
 ih->dport() = RT_PORT;
rreq_lookup(index);
//rsmember(index);
 // Fill up some more fields. 
 rq->rq_type = AODVTYPE_RREQ;
 rq->rq_hop_count = 1;
 rq->rq_bcast_id = bid++;
 rq->rq_dst = dst;
 rq->rq_dst_seqno = (rt ? rt->rt_seqno : 0);
 rq->rq_src = index;
 seqno += 2;
 assert ((seqno%2) == 0);
 rq->rq_src_seqno = seqno;
 rq->rq_timestamp = CURRENT_TIME;

 Scheduler::instance().schedule(target_, p, 0.);

}

void
AODV::sendReply(nsaddr_t ipdst, u_int32_t hop_count, nsaddr_t rpdst,
                u_int32_t rpseq, u_int32_t lifetime, double timestamp) {
Packet *p = Packet::alloc();
struct hdr_cmn *ch = HDR_CMN(p);
struct hdr_ip *ih = HDR_IP(p);
struct hdr_aodv_reply *rp = HDR_AODV_REPLY(p);
aodv_rt_entry *rt = rtable.rt_lookup(ipdst);

#ifdef DEBUG
fprintf(stderr, "sending Reply from %d at %.2f\n", index, Scheduler::instance().clock());
#endif // DEBUG
 assert(rt);
 rp->rp_type = AODVTYPE_RREP;
 //rp->rp_flags = 0x00;
 rp->rp_hop_count = hop_count;
 rp->rp_dst = rpdst;
 rp->rp_dst_seqno = rpseq;
 rp->rp_src = index;
 rp->rp_lifetime = lifetime;
 rp->rp_timestamp = timestamp;
 // ch->uid() = 0;



 ch->ptype() = PT_AODV;
 ch->size() = IP_HDR_LEN + rp->size();
 ch->iface() = -2;
 ch->error() = 0;
 ch->addr_type() = NS_AF_INET;
 ch->next_hop_ = rt->rt_nexthop;
 ch->prev_hop_ = index;          // AODV hack
 ch->direction() = hdr_cmn::DOWN;
 ih->saddr() = index;
 ih->daddr() = ipdst;
 ih->sport() = RT_PORT;
 ih->dport() = RT_PORT;
 ih->ttl_ = NETWORK_DIAMETER;
//printf("reply %d",index);
//rrep_lookup(index);
 Scheduler::instance().schedule(target_, p, 0.);
//rprint1();
}

void
AODV::sendError(Packet *p, bool jitter) {
struct hdr_cmn *ch = HDR_CMN(p);
struct hdr_ip *ih = HDR_IP(p);
struct hdr_aodv_error *re = HDR_AODV_ERROR(p);
    
#ifdef ERROR
fprintf(stderr, "sending Error from %d at %.2f\n", index, Scheduler::instance().clock());
#endif // DEBUG
//rprint();
 re->re_type = AODVTYPE_RERR;
 //re->reserved[0] = 0x00; re->reserved[1] = 0x00;
 // DestCount and list of unreachable destinations are already filled

 // ch->uid() = 0;
 ch->ptype() = PT_AODV;
 ch->size() = IP_HDR_LEN + re->size();
 ch->iface() = -2;
 ch->error() = 0;
 ch->addr_type() = NS_AF_NONE;
 ch->next_hop_ = 0;
 ch->prev_hop_ = index;          // AODV hack
 ch->direction() = hdr_cmn::DOWN;       //important: change the packet's direction

 ih->saddr() = index;
 ih->daddr() = IP_BROADCAST;
 ih->sport() = RT_PORT;
 ih->dport() = RT_PORT;
 ih->ttl_ = 1;

 // Do we need any jitter? Yes
 if (jitter)
 	Scheduler::instance().schedule(target_, p, 0.01*Random::uniform());
 else
 	Scheduler::instance().schedule(target_, p, 0.0);

}


/*
   Neighbor Management Functions
*/

void
AODV::sendHello() {
Packet *p = Packet::alloc();
struct hdr_cmn *ch = HDR_CMN(p);
struct hdr_ip *ih = HDR_IP(p);
struct hdr_aodv_reply *rh = HDR_AODV_REPLY(p);



#ifdef DEBUG
fprintf(stderr, "sending Hello from %d at %.2f\n", index, Scheduler::instance().clock());
#endif // DEBUG

 rh->rp_type = AODVTYPE_HELLO;
 //rh->rp_flags = 0x00;
 rh->rp_hop_count = 1;
 rh->rp_dst = index;
 rh->rp_dst_seqno = seqno;
 rh->rp_lifetime = (1 + ALLOWED_HELLO_LOSS) * HELLO_INTERVAL;

 // ch->uid() = 0;
 ch->ptype() = PT_AODV;
 ch->size() = IP_HDR_LEN + rh->size();
 ch->iface() = -2;
 ch->error() = 0;
 ch->addr_type() = NS_AF_NONE;
 ch->prev_hop_ = index;          // AODV hack

 ih->saddr() = index;
 ih->daddr() = IP_BROADCAST;
 ih->sport() = RT_PORT;
 ih->dport() = RT_PORT;
 ih->ttl_ = 1;

 Scheduler::instance().schedule(target_, p, 0.0);
}


void
AODV::recvHello(Packet *p) {
//struct hdr_ip *ih = HDR_IP(p);
struct hdr_aodv_reply *rp = HDR_AODV_REPLY(p);
AODV_Neighbor *nb;

Node* sender_node = Node::get_node_by_address(rp->rp_dst);
Node* receiver_node = Node::get_node_by_address(index);
sender_node->addNeighbor(receiver_node);
receiver_node->addNeighbor(sender_node);


nb = nb_lookup(rp->rp_dst);
if(nb == 0) 
{
   nb_insert(rp->rp_dst);
 }
 else {
   nb->nb_expire = CURRENT_TIME +
                   (1.5 * ALLOWED_HELLO_LOSS * HELLO_INTERVAL);
 }
/*Node* m_node = Node::get_node_by_address(this->addr());
neighbor_list_node* my_mobile_neighbor_list;
my_mobile_neighbor_list = m_node->neighbor_list_;

                while(my_mobile_neighbor_list)
                            {
                            printf("## Mubashir Neighbor ID:",my_mobile_neighbor_list->nodeid);
                my_mobile_neighbor_list=my_mobile_neighbor_list->next;
                }

//printf("node id : put here node id Mubashir Neighbor list contains ID:",my_mobile_neighbor_list-> nodeid);
 */
Packet::free(p);
}

void
AODV::nb_insert(nsaddr_t id) 
{
AODV_Neighbor *nb = new AODV_Neighbor(id);

 assert(nb);
 //printf("\t%d",id);

nb->nb_expire = CURRENT_TIME +
                (1.5 * ALLOWED_HELLO_LOSS * HELLO_INTERVAL);
 LIST_INSERT_HEAD(&nbhead, nb, nb_link);
 seqno += 2;             // set of neighbors changed
 assert ((seqno%2) == 0);
}



AODV_Neighbor*
AODV::nb_lookup(nsaddr_t id) {
AODV_Neighbor *nb = nbhead.lh_first;

 for(; nb; nb = nb->nb_link.le_next) {
dup(id,nb->nb_addr);
//printf("\n%d \t\t%d",id,nb->nb_addr);

   if(nb->nb_addr == id) break;
 }
 return nb;
}


/*
 * Called when we receive *explicit* notification that a Neighbor
 * is no longer reachable.
 */
void
AODV::nb_delete(nsaddr_t id) {
AODV_Neighbor *nb = nbhead.lh_first;

 log_link_del(id);
 seqno += 2;     // Set of neighbors changed
 assert ((seqno%2) == 0);

 for(; nb; nb = nb->nb_link.le_next) {
   if(nb->nb_addr == id) {
     LIST_REMOVE(nb,nb_link);
     delete nb;
     break;
   }
 }

 handle_link_failure(id);

}


/*
 * Purges all timed-out Neighbor Entries - runs every
 * HELLO_INTERVAL * 1.5 seconds.
 */
void
AODV::nb_purge() {
AODV_Neighbor *nb = nbhead.lh_first;
AODV_Neighbor *nbn;
double now = CURRENT_TIME;

 for(; nb; nb = nbn) {
   nbn = nb->nb_link.le_next;
   if(nb->nb_expire <= now) {
     nb_delete(nb->nb_addr);
   }
 }

}
void 
AODV::mal_lookup(nsaddr_t id,u_int32_t seqno)
 {
if(ss==0)
{
ss=seqno;
}
else
{

if(ss < seqno )
{
//ss=seqno;
for (i=0;i<50;i++)
{
if(val[i]==id)
{
ab[id]+=1;
FILE *out_file ;
char nowfile[150] = "ab1.txt";

out_file = fopen(nowfile, "a");

fprintf(out_file, "%d \t %d\n",val[id],ab[id]);

fclose(out_file);


}}}}
/*for(i=0;i<50;i++)
{
printf("\n%d\t%d",val[i],ab[i]);
}*/
}
int
AODV::rreq_lookup(nsaddr_t id)
 {

for (i=0;i<50;i++)
{
if(val[i]==id)
{
rreq[id]+=1;

FILE *out_file ;
char nowfile[150] = "rreq1.txt";

out_file = fopen(nowfile, "a");

fprintf(out_file, "%d \t %d\n",val[id],rreq[id]);

fclose(out_file);
}}

//printf("\n%d%d",);

}
void
AODV::rrep_lookup(nsaddr_t id)
 {
for (i=0;i<50;i++)
{
if(val1[i]==id)
{
rrep[id]+=1;
FILE *out_file ;
char nowfile[150] = "rrep1.txt";

out_file = fopen(nowfile, "a");

fprintf(out_file, "%d \t %d\n",val[id],rrep[id]);

fclose(out_file);

}}
//printf("\n%d",id);
}
void 
AODV::rt_input()
{
i=0;v=0;
FILE *fp;
fp=fopen("rrep.txt","r");
while((v=getw(fp))!=EOF)
{
rrep1[i]=v;
i++;
}
fclose(fp);
for(i=0;i<4;i++)
{
printf("\n%d",rrep1[i]);
}
}
void
AODV::reqmember()
{
double a;
for(i=0;i<50;i++)
{
if(rreq1[i]<=50)
{
rreq2[i]='L';
}
else if(rreq1[i]>50 && rreq1[i]<60)
{
a=0;
a=((60-(double) rreq1[i])/10);
if(a>=0.6)
{
rreq2[i]='L';
}
else if(a<0.6)
{
rreq2[i]='H';
}
}
else if(rreq1[i]>=60 && rreq1[i]<=80)
{
rreq2[i]='H';
}
else if(rreq1[i]>80 && rreq1[i]<90)
{
a=0;
a=((90-(double)rreq1[i])/10);
if (a>=0.6)
{
rreq2[i]='H';
}
else if(a<0.6)
{
rreq2[i]='V';
}
}
else if(rreq1[i]>=90)
{
rreq2[i]='V';//changed today
}
}
}
void
AODV::repmember()
{
double a;
for(i=0;i<50;i++)
{
if(rrep1[i]<=5)
{
rrep2[i]='L';
}
else if(rrep1[i]>5 && rrep1[i]<=10)
{
a=0;
a=((10-(double)rrep1[i])/5);
if(a>=0.6)
{
rrep2[i]='L';
}
else if(a<0.6)
{
rrep2[i]='H';
}
}
else if(rrep1[i]>10)
{
rrep2[i]='H';
}
}
}

void
AODV::abmember()
{
double a;
for(i=0;i<50;i++)
{
if(ab1[i]<=10)
{
ab2[i]='L';
}
else if(ab1[i]>10 && ab1[i]<=15)
{
a=0;
a=((15-(double)ab1[i])/5);
if(a>=0.6)
{
ab2[i]='L';
}
else if(a<0.6)
{
ab2[i]='M';
}
}
else if(ab1[i]>15 && ab1[i]<=20)
{
a=0;
a=((20-(double)ab1[i])/5);
if(a>=0.6)
{
ab2[i]='M';
}
else if(a<0.6)
{
ab2[i]='H';
}
}
else if(ab1[i]>20)
{
ab2[i]='H';
}
}
}
void 
AODV::tcal()
{
for(i=0;i<50;i++)
{
if(rreq2[i]=='L' && rrep2[i]=='L' && ab2[i]=='L')
{
t[i]='S';
}
else if(rreq2[i]=='L' && rrep2[i]=='L' && ab2[i]=='M')
{
t[i]='S';
}
else if(rreq2[i]=='L' && rrep2[i]=='L' && ab2[i]=='H')
{
t[i]='F';
}
else if(rreq2[i]=='L' && rrep2[i]=='H' && ab2[i]=='L')
{
t[i]='M';
}
else if(rreq2[i]=='L' && rrep2[i]=='H' && ab2[i]=='M')
{
t[i]='L';
}
else if(rreq2[i]=='L' && rrep2[i]=='H' && ab2[i]=='H')
{
t[i]='F';
}
else if(rreq2[i]=='H' && rrep2[i]=='L' && ab2[i]=='L')
{
t[i]='M';
}
else if(rreq2[i]=='H' && rrep2[i]=='L' && ab2[i]=='M')
{
t[i]='H';
}
else if(rreq2[i]=='H' && rrep2[i]=='L' && ab2[i]=='H')
{
t[i]='L';
}
else if(rreq2[i]=='H' && rrep2[i]=='H' && ab2[i]=='L')
{
t[i]='M';
}
else if(rreq2[i]=='H' && rrep2[i]=='H' && ab2[i]=='M')
{
t[i]='L';
}
else if(rreq2[i]=='H' && rrep2[i]=='H' && ab2[i]=='H')
{
t[i]='F';
}
else if(rreq2[i]=='V' && rrep2[i]=='L' && ab2[i]=='L')
{
t[i]='M';
}
else if(rreq2[i]=='V' && rrep2[i]=='L' && ab2[i]=='M')
{
t[i]='L';
}
else if(rreq2[i]=='V' && rrep2[i]=='L' && ab2[i]=='H')
{
t[i]='L';
}
else if(rreq2[i]=='V' && rrep2[i]=='H' && ab2[i]=='L')
{
t[i]='M';
}
else if(rreq2[i]=='V' && rrep2[i]=='H' && ab2[i]=='M')
{
t[i]='M';
}
else if(rreq2[i]=='V' && rrep2[i]=='H' && ab2[i]=='H')
{
t[i]='F';
}
}
}
void 
AODV::dup(nsaddr_t id,nsaddr_t a)
{
/*int as=0;
for(i=0;i<50;i++)
{ as=0;
if(val[i]==id)
{
//printf("\n%d",id);
for(j=1;j<10;j++)
{
if(nn[i][j]!=a)
{as++;
nn[i][as]=a;
//printf("\t\t%d",nn[i][as+1]);
}}
}}

printf("\n%d\t\t%d,",val[0],nn[0]);
printf("\n%d\t\t%d",val[1],nn[1]);
printf("\n%d\t\t%d",val[2],nn[2]);
printf("\n%d\t\t%d",val[3],nn[3]);
printf("\n%d\t\t%d",val[4],nn[4]);

*/
/*FILE *o_file ;
char nowfile[50] = "ntrust.txt";

o_file = fopen(nowfile, "a");
fprintf(o_file,"\nNode id\tNeighbour\tTrust");
fprintf(o_file,"\n_______________________________");
fprintf(o_file, "\n%d\t\t%d \t\t%c", id,a,t[a]);
	 
  fclose(o_file);

*/
}
/*void 
AODV::rsmember(nsaddr_t id)
{
for(i=0;i<10;i++)
{
if (val[i]==id)
{
rs[id]+=1;
}
}
}
void 
AODV::rfmember(nsaddr_t id)
{
for(i=0;i<10;i++)
{
if(val[i]==id)
{
rf[id]+=1;
}
}
}


void
AODV::cal()
{
for(i=0;i<10;i++)
{
if(rs[i]==rf[i])
{
tt[i]=1;
}
else
{
//tt[i]=1-((rs[i]-rf[i])/(rs[i]+rf[i]));
}
}

}




void 
AODV::rqsmember(nsaddr_t id)
{
for(i=0;i<10;i++)
{
if (val[i]==id)
{
rqs[id]+=1;
}
}
}
void 
AODV::rqfmember(nsaddr_t id)
{
for(i=0;i<10;i++)
{
if(val[i]==id)
{
rqf[id]+=1;
}
}
}

void
AODV::cal1()
{
for(i=0;i<10;i++)
{
if(rqs[i]==rqf[i])
{
tt1[i]=1.0;
}
else 
{
//tt1[i]=0.0;
//
tt1[i]=rqf[i]/rqs[i];
//tt1[i]=1-((rqs[i]-rqf[i])/(rqs[i]+rqf[i]));
//printf("\t\t%d",rqs[i]);
}
}

}
*/
void
AODV::rreqcall()
{
FILE *f;
 int s[35000],count,ar1[25000],ar2[25000],temp[25000];
count=0;
int j=0,p=0,l=0;
f=fopen("rreq1.txt","r");
//f1=fopen("newrreq.txt","w");
if(f!=NULL)
{
while((fscanf(f,"%d\n",&s[count])!=EOF))
{
count++;
}
for(i=0;i<count;i++)
{
ar1[i]=ar2[i]=temp[i]=0;
}
for(i=0;i<count;i++)
{
if((i%2)==0)
{
ar1[p]=s[i];
p++;
}
else
{
ar2[j]=s[i];
j++;
}
}
for(l=0;l<50;l++)
{
for(i=0;i<count;i++)
{
if(ar1[i]==l)
{
if(ar2[i]>=temp[l])
{
temp[l]=ar2[i];
}
}
}
}
for(i=0;i<50;i++)
{
rreq1[i]=temp[i];
}
}

else if(f==NULL)
{
for(i=0;i<50;i++)
{
rreq1[i]=0;
}
}
/*for(i=0;i<50;i++)
{
printf("%d\t%d\n",val[i],rreq1[i]);
}*/
fclose(f);
}


void
AODV::rrepcall()
{
FILE *f;
int s[35000],count,ar1[25000],ar2[25000],temp[25000];
count=0;
int j=0,p=0,l=0;
f=fopen("rrep1.txt","r");
if(f!=NULL)
{
while((fscanf(f,"%d\n",&s[count])!=EOF))
{
count++;
}
for(i=0;i<count;i++)
{
ar1[i]=ar2[i]=temp[i]=0;
}
for(i=0;i<count;i++)
{
if((i%2)==0)
{
ar1[p]=s[i];
p++;
}
else
{
ar2[j]=s[i];
j++;
}
}
for(l=0;l<50;l++)
{
for(i=0;i<count;i++)
{
if(ar1[i]==l)
{
if(ar2[i]>=temp[l])
{
temp[l]=ar2[i];
}
}
}
}
for(i=0;i<50;i++)
{
rrep1[i]=temp[i];
}
}
else if(f==NULL)
{
for(i=0;i<50;i++)
{
rrep1[i]=0;
}
}
fclose(f);
}


void
AODV::abcall()
{
FILE *f;
int s[35000],count,ar1[25000],ar2[25000],temp[25000];
count=0;
int j=0,p=0,l=0;
f=fopen("ab1.txt","r");
if(f!=NULL)
{
while((fscanf(f,"%d\n",&s[count])!=EOF))
{
count++;
}
for(i=0;i<count;i++)
{
ar1[i]=ar2[i]=temp[i]=0;
}
for(i=0;i<count;i++)
{
if((i%2)==0)
{
ar1[p]=s[i];
p++;
}
else
{
ar2[j]=s[i];
j++;
}
}
for(l=0;l<50;l++)
{
for(i=0;i<count;i++)
{
if(ar1[i]==l)
{
if(ar2[i]>=temp[l])
{
temp[l]=ar2[i];
}
}
}
}
for(i=0;i<50;i++)
{
ab1[i]=temp[i];
}
}
else if(f==NULL)
{
for(i=0;i<50;i++)
{
ab1[i]=0;
}
}
fclose(f);
}

void
AODV::tprint()
{
printf("\nNode\tRREQ\tRREP\tAB\tTrust");
for(i=0;i<50;i++)
{
printf("\n%d\t%d\t%d\t%d\t%c",val[i],rreq1[i],rrep1[i],ab1[i],t[i]);
}
FILE *out_file ;
char nowfile[150] = "trust.txt";

out_file = fopen(nowfile, "a");
fprintf(out_file,"Node\tRREQ\t\tRREP\t\tAB\t\tTRUST\n");
for(i=0;i<50;i++)
{
fprintf(out_file, "\n%d \t %d \t(%c) \t %d \t (%c)\t %d \t(%c)\t %c",val[i],rreq1[i],rreq2[i],rrep1[i],rrep2[i],ab1[i],ab2[i],t[i]);
}
fclose(out_file);

}



void 
AODV::mal_lookup1(nsaddr_t id,u_int32_t seqno)
 {
if(ss1==0)
{
ss1=seqno;
}
else
{
	if(ss1 < seqno )
{
//ss=seqno;
for (i=0;i<50;i++)
{
if(val[i]==id)
{
ab[id]+=1;
FILE *out_file ;
char nowfile[150] = "rreq1.txt";

out_file = fopen(nowfile, "a");

fprintf(out_file, "%d \t %d\n",val[id],ab[id]);

fclose(out_file);

}
}}}
/*for(i=0;i<50;i++)
{
printf("\n\t%d",ab[i]);
}*/
}

void
AODV::rreq1call()
{
FILE *f;
int s[200],count;
count=0;
f=fopen("newrreq.txt","r");
while((fscanf(f,"%d\n",&s[count])!=EOF))
{
count++;
}
for(i=0;i<count;i++)
{
rreq1[i]=s[i];
}
fclose(f);
}


Aodv.h file
/*
Copyright (c) 1997, 1998 Carnegie Mellon University.  All Rights
Reserved. 

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.
3. The name of the author may not be used to endorse or promote products
derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

The AODV code developed by the CMU/MONARCH group was optimized and tuned by Samir Das and Mahesh Marina, University of Cincinnati. The work was partially done in Sun Microsystems.

*/

#ifndef __aodv_h__
#define __aodv_h__

//#include <agent.h>
//#include <packet.h>
//#include <sys/types.h>
//#include <cmu/list.h>
//#include <scheduler.h>

#include <cmu-trace.h>
#include <priqueue.h>
#include <aodv/aodv_rtable.h>
#include <aodv/aodv_rqueue.h>
#include <classifier/classifier-port.h>

/*
  Allows local repair of routes 
*/
#define AODV_LOCAL_REPAIR

/*
  Allows AODV to use link-layer (802.11) feedback in determining when
  links are up/down.
*/
#define AODV_LINK_LAYER_DETECTION

/*
  Causes AODV to apply a "smoothing" function to the link layer feedback
  that is generated by 802.11.  In essence, it requires that RT_MAX_ERROR
  errors occurs within a window of RT_MAX_ERROR_TIME before the link
  is considered bad.
*/
#define AODV_USE_LL_METRIC

/*
  Only applies if AODV_USE_LL_METRIC is defined.
  Causes AODV to apply omniscient knowledge to the feedback received
  from 802.11.  This may be flawed, because it does not account for
  congestion.
*/
//#define AODV_USE_GOD_FEEDBACK


class AODV;

#define MY_ROUTE_TIMEOUT        10                        // 100 seconds
#define ACTIVE_ROUTE_TIMEOUT    10				// 50 seconds
#define REV_ROUTE_LIFE          6				// 5  seconds
#define BCAST_ID_SAVE           6				// 3 seconds


// No. of times to do network-wide search before timing out for 
// MAX_RREQ_TIMEOUT sec. 
#define RREQ_RETRIES            3  
// timeout after doing network-wide search RREQ_RETRIES times
#define MAX_RREQ_TIMEOUT	10.0 //sec

/* Various constants used for the expanding ring search */
#define TTL_START     5
#define TTL_THRESHOLD 7
#define TTL_INCREMENT 2 

// This should be somewhat related to arp timeout
#define NODE_TRAVERSAL_TIME     0.03             // 30 ms
#define LOCAL_REPAIR_WAIT_TIME  0.15 //sec

// Should be set by the user using best guess (conservative) 
#define NETWORK_DIAMETER        30             // 30 hops

// Must be larger than the time difference between a node propagates a route 
// request and gets the route reply back.

//#define RREP_WAIT_TIME     (3 * NODE_TRAVERSAL_TIME * NETWORK_DIAMETER) // ms
//#define RREP_WAIT_TIME     (2 * REV_ROUTE_LIFE)  // seconds
#define RREP_WAIT_TIME         1.0  // sec

#define ID_NOT_FOUND    0x00
#define ID_FOUND        0x01
//#define INFINITY        0xff

// The followings are used for the forward() function. Controls pacing.
#define DELAY 1.0           // random delay
#define NO_DELAY -1.0       // no delay 

// think it should be 30 ms
#define ARP_DELAY 0.01      // fixed delay to keep arp happy


#define HELLO_INTERVAL          1               // 1000 ms
#define ALLOWED_HELLO_LOSS      3               // packets
#define BAD_LINK_LIFETIME       3               // 3000 ms
#define MaxHelloInterval        (1.25 * HELLO_INTERVAL)
#define MinHelloInterval        (0.75 * HELLO_INTERVAL)

/*
  Timers (Broadcast ID, Hello, Neighbor Cache, Route Cache)
*/
class BroadcastTimer : public Handler {
public:
        BroadcastTimer(AODV* a) : agent(a) {}
        void	handle(Event*);
private:
        AODV    *agent;
	Event	intr;
};

class HelloTimer : public Handler {
public:
        HelloTimer(AODV* a) : agent(a) {}
        void	handle(Event*);
private:
        AODV    *agent;
	Event	intr;
};

class NeighborTimer : public Handler {
public:
        NeighborTimer(AODV* a) : agent(a) {}
        void	handle(Event*);
private:
        AODV    *agent;
	Event	intr;
};

class RouteCacheTimer : public Handler {
public:
        RouteCacheTimer(AODV* a) : agent(a) {}
        void	handle(Event*);
private:
        AODV    *agent;
	Event	intr;
};

class LocalRepairTimer : public Handler {
public:
        LocalRepairTimer(AODV* a) : agent(a) {}
        void	handle(Event*);
private:
        AODV    *agent;
	Event	intr;
};


/*
  Broadcast ID Cache
*/
class BroadcastID {
        friend class AODV;
 public:
        BroadcastID(nsaddr_t i, u_int32_t b) { src = i; id = b;  }
 protected:
        LIST_ENTRY(BroadcastID) link;
        nsaddr_t        src;
        u_int32_t       id;
        double          expire;         // now + BCAST_ID_SAVE s
		};

LIST_HEAD(aodv_bcache, BroadcastID);


/*
  The Routing Agent
*/
class AODV: public Agent {

  /*
   * make some friends first 
   */

        friend class aodv_rt_entry;
        friend class BroadcastTimer;
        friend class HelloTimer;
        friend class NeighborTimer;
        friend class RouteCacheTimer;
        friend class LocalRepairTimer;

 public:
        AODV(nsaddr_t id);
	double trust;
	
        void		recv(Packet *p, Handler *);

 protected:
        int             command(int, const char *const *);
        int             initialized() { return 1 && target_; }

        /*
         * Route Table Management
         */
        void            rt_resolve(Packet *p);
        void            rt_update(aodv_rt_entry *rt, u_int32_t seqnum,
		     	  	u_int16_t metric, nsaddr_t nexthop,
		      		double expire_time);
        void            rt_down(aodv_rt_entry *rt);

      void  rt_print(nsaddr_t node_id);

        void            local_rt_repair(aodv_rt_entry *rt, Packet *p);
 public:
        void            rt_ll_failed(Packet *p);
        void            handle_link_failure(nsaddr_t id);
 protected:
        void            rt_purge(void);

        void            enque(aodv_rt_entry *rt, Packet *p);
        Packet*         deque(aodv_rt_entry *rt);

        /*
         * Neighbor Management
         */
        void            nb_insert(nsaddr_t id);
        AODV_Neighbor*       nb_lookup(nsaddr_t id);
      void       mal_lookup(nsaddr_t id,u_int32_t seqnum);
      int       rreq_lookup(nsaddr_t id);
	void rrep_lookup(nsaddr_t id);
void rprint();
void rprint1();
void rt_input();  
void reqmember();
void repmember();
void abmember();
void tcal();
void rprint2();
void rsmember(nsaddr_t id);
void rfmember(nsaddr_t id);
void cal();
void rreqcall();
void rreq1call();
void rrepcall();
void abcall();
void tprint();
void mal_lookup1(nsaddr_t id,u_int32_t seqnum);
void dup(nsaddr_t id,nsaddr_t a);       
//void rqsmember(nsaddr_t id);
//void rqfmember(nsaddr_t id);
//void cal1();

	void            nb_delete(nsaddr_t id);
        void            nb_purge(void);

        /*
         * Broadcast ID Management
         */

        void            id_insert(nsaddr_t id, u_int32_t bid);
        bool	        id_lookup(nsaddr_t id, u_int32_t bid);
        void            id_purge(void);

        /*
         * Packet TX Routines
         */
        void            forward(aodv_rt_entry *rt, Packet *p, double delay);
        void            sendHello(void);
        void            sendRequest(nsaddr_t dst);

        void            sendReply(nsaddr_t ipdst, u_int32_t hop_count,
                                  nsaddr_t rpdst, u_int32_t rpseq,
                                  u_int32_t lifetime, double timestamp);
        void            sendError(Packet *p, bool jitter = true);
                                          
        /*
         * Packet RX Routines
         */
        void            recvAODV(Packet *p);
        void            recvHello(Packet *p);
        void            recvRequest(Packet *p);
        void            recvReply(Packet *p);
        void            recvError(Packet *p);

	/*
	 * History management
	 */
	
	double 		PerHopTime(aodv_rt_entry *rt);
  bool malicious;
	long int ab[150],ab1[150];char ab2[150];
long int rreq[150],rreq1[150];char rreq2[150];
long int rrep[150],rrep1[150];char rrep2[150];
long int val[150];
long int val1[150];
int num;
int i,j,v;
int ss,ss1;
char t[150];
int nn[50][50];
double rs[50],rf[50],rqs[50],rqf[50];
double tt[50],tt1[50];

        nsaddr_t        index;                  // IP Address of this node
        u_int32_t       seqno;                  // Sequence Number
        int             bid;                    // Broadcast ID

        aodv_rtable         rthead;                 // routing table
        aodv_ncache         nbhead;                 // Neighbor Cache
        aodv_bcache          bihead;                 // Broadcast ID Cache

        /*
         * Timers
         */
        BroadcastTimer  btimer;
        HelloTimer      htimer;
        NeighborTimer   ntimer;
        RouteCacheTimer rtimer;
        LocalRepairTimer lrtimer;

        /*
         * Routing Table
         */
        aodv_rtable          rtable;
        /*
         *  A "drop-front" queue used by the routing layer to buffer
         *  packets to which it does not have a route.
         */
        aodv_rqueue         rqueue;

        /*
         * A mechanism for logging the contents of the routing
         * table.
         */
        Trace           *logtarget;

        /*
         * A pointer to the network interface queue that sits
         * between the "classifier" and the "link layer".
         */
        PriQueue        *ifqueue;

        /*
         * Logging stuff
         */
        void            log_link_del(nsaddr_t dst);
        void            log_link_broke(Packet *p);
        void            log_link_kept(nsaddr_t dst);

	/* for passing packets up to agents */
	PortClassifier *dmux_;

};

#endif /* __aodv_h__ */
